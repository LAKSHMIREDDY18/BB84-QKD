<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BB84 Quantum Key Distribution Simulation & Presentation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Use Inter font */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for basis representation */
        .basis-z { /* Rectilinear */
            color: blue;
            font-weight: bold;
        }
        .basis-x { /* Diagonal */
            color: green;
            font-weight: bold;
        }
        /* Style for table cells indicating match/mismatch */
        .match { background-color: #a7f3d0; } /* Tailwind green-200 */
        .mismatch { background-color: #fecaca; } /* Tailwind red-200 */
        .key-bit { font-weight: bold; }
        /* Basic button styling improvement */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Ensure canvas is responsive */
        canvas {
            max-width: 100%;
            height: auto;
        }
        /* Add some spacing for presentation sections */
        #presentation h3 {
            margin-top: 1.5rem; /* Equivalent to mb-6 roughly */
            margin-bottom: 0.5rem; /* Equivalent to mb-2 roughly */
        }
         #presentation p, #presentation ul, #presentation dl {
             margin-bottom: 1rem; /* Spacing below paragraphs/lists */
         }
         #presentation ul {
             list-style-position: inside;
             margin-left: 1rem;
         }
         #presentation code {
             background-color: #f3f4f6; /* gray-100 */
             padding: 0.1rem 0.3rem;
             border-radius: 0.25rem;
             font-size: 0.875rem; /* text-sm */
         }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4 md:p-8">
    <div class="max-w-6xl mx-auto bg-white p-6 rounded-lg shadow-lg">

        <header class="text-center mb-10">
             <h1 class="text-2xl md:text-3xl font-bold text-center mb-2 text-indigo-700">BB84 Quantum Key Distribution</h1>
             <p class="text-lg text-gray-600">Presentation & Interactive Simulator</p>
        </header>

        <section id="presentation" class="mb-12 border-b pb-8">
            <h2 class="text-2xl font-semibold text-indigo-600 mb-6 text-center">Project Overview</h2>

            <div>
                <h3 class="text-xl font-semibold text-gray-700">1. Introduction to QKD & BB84</h3>
                <p class="text-gray-600">
                    Quantum Key Distribution (QKD) leverages principles of quantum mechanics to establish a secure shared secret key between two parties (Alice and Bob) over an insecure channel, potentially monitored by an eavesdropper (Eve). The security relies on the fundamental quantum principle that measuring a quantum system generally disturbs it, leaving detectable traces.
                </p>
                <p class="text-gray-600">
                    The BB84 protocol (named after its inventors Charles Bennett and Gilles Brassard, 1984) is the pioneering and most well-known QKD protocol. Its core steps are:
                </p>
                <ul class="list-disc text-gray-600 space-y-1">
                    <li><strong>Alice Sends Qubits:</strong> Alice generates a sequence of random classical bits. For each bit, she randomly chooses one of two encoding bases (e.g., Rectilinear '+' or Diagonal 'x') and prepares a qubit representing her bit in that chosen basis. She sends these qubits to Bob over a quantum channel.</li>
                    <li><strong>Bob Measures Qubits:</strong> For each qubit received, Bob randomly chooses one of the two bases ('+' or 'x') to perform a measurement. He records his basis choice and the measurement outcome (bit value).</li>
                    <li><strong>Basis Reconciliation (Public Discussion):</strong> Alice and Bob communicate over an authenticated public channel (like a phone call or signed messages). They compare the sequence of bases they used for each qubit. They keep only the bits where their basis choices matched and discard all others.</li>
                    <li><strong>Key Sifting:</strong> The sequence of bits kept after basis reconciliation forms the 'sifted key'. In an ideal, noiseless scenario without eavesdropping, Alice's and Bob's sifted keys should be identical.</li>
                    <li><strong>Parameter Estimation (Error Checking):</strong> Alice and Bob publicly compare a randomly chosen subset of their sifted key bits. This allows them to estimate the Quantum Bit Error Rate (QBER) â€“ the percentage of mismatching bits. A QBER significantly above the expected noise level indicates the likely presence of an eavesdropper (Eve), as Eve's attempts to measure the qubits inevitably introduce errors.</li>
                    <li><strong>Error Correction & Privacy Amplification (Not Simulated Here):</strong> If the QBER is below a predetermined security threshold, Alice and Bob use classical error correction algorithms to remove errors from the remaining sifted key bits. Then, they apply privacy amplification techniques (hashing) to distill a shorter, highly secure final key, about which Eve has negligible information.</li>
                </ul>
            </div>

            <div>
                <h3 class="text-xl font-semibold text-gray-700">2. Simulator Implementation Details</h3>
                <p class="text-gray-600">
                    This interactive simulator models the BB84 protocol using classical computation (JavaScript within your browser). It doesn't involve real quantum hardware but accurately simulates the *probabilistic outcomes* and *information disturbance* effects central to BB84's security:
                </p>
                <ul class="list-disc text-gray-600 space-y-1">
                    <li>Pseudo-random number generators are used for creating Alice's bits, Alice's basis choices, Bob's basis choices, and (if active) Eve's basis choices.</li>
                    <li>Qubit states are represented abstractly by their encoded bit value and the basis used for encoding (e.g., {bit: 0, basis: 'X'}).</li>
                    <li>Measurement simulation strictly follows BB84 quantum mechanics principles:
                        <ul>
                            <li>If Bob measures in the *same basis* Alice used to prepare the qubit, he deterministically obtains Alice's original bit value.</li>
                            <li>If Bob measures in a *different basis* than Alice used, the quantum state collapses randomly, giving him a 0 or 1 outcome with equal (50%) probability, irrespective of Alice's original bit.</li>
                        </ul>
                    </li>
                    <li>Eavesdropping (Eve) is simulated using a common strategy: the "Intercept-Resend Attack". Eve measures each qubit sent by Alice using her own randomly chosen basis. She then prepares and sends a *new* qubit to Bob, encoded with *her measured bit* in *her chosen basis*. This act of measurement and resending inevitably introduces errors into the sequence Bob receives whenever Eve's basis choice differs from Alice's original basis.</li>
                    <li>The simulation calculates the final sifted keys for Alice and Bob after basis reconciliation and computes the QBER by comparing their sifted keys.</li>
                    <li>Visualizations (panels, table, chart) help illustrate the process and the impact of eavesdropping on the QBER.</li>
                </ul>
            </div>

             <div>
                <h3 class="text-xl font-semibold text-gray-700">3. How the Simulator Code Works (JavaScript)</h3>
                <p class="text-gray-600">
                    The core logic resides in the JavaScript embedded within this HTML page. Key functions and steps include:
                </p>
                <ul class="list-disc text-gray-600 space-y-1">
                    <li><code>generateRandomBit()</code>: Returns 0 or 1.</li>
                    <li><code>generateRandomBasis()</code>: Returns 'Z' (Rectilinear) or 'X' (Diagonal).</li>
                    <li><code>alicePreparation()</code>: Generates Alice's initial random bits and bases.</li>
                    <li><code>simulateEveMeasurement()</code>: If Eve is active, this function simulates her intercepting Alice's qubits, measuring them in random bases (<code>eveBases</code>, <code>eveMeasured</code>), and preparing new qubits based on her results to send to Bob.</li>
                    <li><code>bobMeasurement()</code>: Simulates Bob choosing random bases (<code>bobBases</code>) and measuring the qubits he receives (either directly from Alice or altered by Eve). Calculates <code>bobResults</code> based on the basis comparison rules.</li>
                    <li><code>extractSiftedKey()</code>: Compares Alice's original bases (<code>aliceBases</code>) with Bob's measurement bases (<code>bobBases</code>). It keeps Alice's original bits (for <code>aliceKey</code>) and Bob's measured bits (for <code>bobKey</code>) only for the positions where the bases matched.</li>
                    <li><code>calculateQBER()</code>: Compares <code>aliceKey</code> and <code>bobKey</code> bit-by-bit to find the error rate.</li>
                    <li><strong>Event Handlers (Buttons):</strong>
                        <ul>
                          <li><code>Start Simulation</code>: Calls <code>alicePreparation</code> and <code>bobMeasurement</code> (assuming no Eve initially). Enables other buttons.</li>
                           <li><code>Simulate Eve Interception</code>: Calls <code>simulateEveMeasurement</code> and then updates Bob's state by calling <code>bobMeasurement</code> again with the qubits Eve sent. Updates Eve's panel.</li>
                           <li><code>Compare Bases & Get Key</code>: Calls <code>extractSiftedKey</code> for both Alice and Bob, calculates QBER, updates the results displays (keys, QBER, table, chart), and disables further actions for the current run.</li>
                        </ul>
                    </li>
                    <li><strong>UI Update Functions:</strong> Functions like <code>updatePanels</code>, <code>generateDetailedTable</code>, <code>updateQBERDisplay</code>, and <code>updateChart</code> dynamically refresh the HTML content to reflect the simulation state at each step.</li>
                </ul>
                 <p class="text-gray-600 mt-2">
                   The visualization uses simple text displays, a detailed HTML table (toggleable), and a Chart.js line chart to clearly show the bits, bases, matching status, final keys, and key comparison.
                </p>
            </div>

        </section>

        <section id="simulator">
            <h2 class="text-2xl font-semibold text-indigo-600 mb-6 text-center">Interactive Simulator</h2>

            <div class="setup bg-gray-50 p-4 rounded-md shadow-sm mb-8 flex flex-col sm:flex-row items-center justify-center space-y-4 sm:space-y-0 sm:space-x-4">
                <div class="flex items-center space-x-2">
                    <label for="num-qubits" class="font-medium text-gray-700">Number of Qubits:</label>
                    <input type="number" id="num-qubits" value="20" min="4" max="100" class="w-20 p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <button id="btn-start" class="w-full sm:w-auto px-4 py-2 bg-indigo-600 text-white font-semibold rounded-md shadow hover:bg-indigo-700 transition duration-150 ease-in-out">
                    Start Simulation
                </button>
                <button id="btn-eve" class="w-full sm:w-auto px-4 py-2 bg-red-600 text-white font-semibold rounded-md shadow hover:bg-red-700 transition duration-150 ease-in-out" disabled>
                    Simulate Eve Interception
                </button>
                 <button id="btn-compare" class="w-full sm:w-auto px-4 py-2 bg-green-600 text-white font-semibold rounded-md shadow hover:bg-green-700 transition duration-150 ease-in-out" disabled>
                    Compare Bases & Get Key
                </button>
            </div>

            <div class="panels grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                <div id="alice-panel" class="bg-blue-50 p-4 rounded-lg shadow">
                    <h3 class="text-xl font-semibold mb-3 text-blue-800">Alice (Sender)</h3>
                    <div class="space-y-2 text-sm">
                        <p><span class="font-medium">Bits Sent:</span> <span id="alice-bits" class="font-mono break-all">-</span></p>
                        <p><span class="font-medium">Bases Used:</span> <span id="alice-bases" class="font-mono break-all">-</span></p>
                        <p class="mt-4 font-medium">Sifted Key: <span id="alice-key" class="font-mono text-blue-900 font-bold">-</span></p>
                    </div>
                </div>

                <div id="bob-panel" class="bg-green-50 p-4 rounded-lg shadow">
                    <h3 class="text-xl font-semibold mb-3 text-green-800">Bob (Receiver)</h3>
                     <div class="space-y-2 text-sm">
                        <p><span class="font-medium">Bases Chosen:</span> <span id="bob-bases" class="font-mono break-all">-</span></p>
                        <p><span class="font-medium">Measured Results:</span> <span id="bob-results" class="font-mono break-all">-</span></p>
                        <p class="mt-4 font-medium">Sifted Key: <span id="bob-key" class="font-mono text-green-900 font-bold">-</span></p>
                    </div>
                </div>

                 <div id="eve-panel" class="bg-red-50 p-4 rounded-lg shadow" style="display: none;">
                    <h3 class="text-xl font-semibold mb-3 text-red-800">Eve (Eavesdropper)</h3>
                     <div class="space-y-2 text-sm">
                        <p><span class="font-medium">Bases Chosen:</span> <span id="eve-bases" class="font-mono break-all">-</span></p>
                        <p><span class="font-medium">Intercepted Bits:</span> <span id="eve-measured" class="font-mono break-all">-</span></p>
                        <p class="mt-2 text-xs text-red-700">Eve measures Alice's qubits and resends new ones to Bob based on her measurements.</p>
                    </div>
                </div>
            </div>

            <div class="results bg-gray-50 p-4 rounded-lg shadow mb-8">
                <h3 class="text-xl font-semibold mb-4 text-center text-gray-700">Simulation Results & Analysis</h3>
                <div class="text-center mb-4">
                     <p class="text-lg font-medium">Quantum Bit Error Rate (QBER): <span id="qber" class="font-bold text-xl text-purple-700">N/A</span></p>
                     <p id="qber-message" class="text-sm text-gray-600 mt-1"></p>
                </div>

                <div class="mb-6 h-64"> <canvas id="key-chart"></canvas>
                </div>

                 <div class="text-center mb-4">
                    <button id="show-table-btn" class="px-3 py-1 bg-gray-200 text-gray-700 text-sm font-medium rounded hover:bg-gray-300" style="display: none;">
                        Show Detailed Steps
                    </button>
                </div>

                <div id="key-table-container" class="overflow-x-auto" style="display: none;">
                     <table class="min-w-full divide-y divide-gray-200 border border-gray-200">
                        <thead class="bg-gray-100">
                            <tr>
                                <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">#</th>
                                <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Alice Bit</th>
                                <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Alice Basis</th>
                                <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Eve Basis</th>
                                <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Eve Measure</th>
                                <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Bob Basis</th>
                                <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Bob Result</th>
                                <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Basis Match (A-B)</th>
                                <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Sifted Bit (A)</th>
                                <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Sifted Bit (B)</th>
                            </tr>
                        </thead>
                        <tbody id="key-table-body" class="bg-white divide-y divide-gray-200">
                            </tbody>
                    </table>
                </div>
            </div>
        </section>

    </div>

    <script>
        // --- DOM Element References ---
        const numQubitsInput = document.getElementById('num-qubits');
        const startBtn = document.getElementById('btn-start');
        const eveBtn = document.getElementById('btn-eve');
        const compareBtn = document.getElementById('btn-compare');
        const aliceBitsSpan = document.getElementById('alice-bits');
        const aliceBasesSpan = document.getElementById('alice-bases');
        const bobBasesSpan = document.getElementById('bob-bases');
        const bobResultsSpan = document.getElementById('bob-results');
        const evePanel = document.getElementById('eve-panel');
        const eveBasesSpan = document.getElementById('eve-bases');
        const eveMeasuredSpan = document.getElementById('eve-measured');
        const aliceKeySpan = document.getElementById('alice-key');
        const bobKeySpan = document.getElementById('bob-key');
        const qberSpan = document.getElementById('qber');
        const qberMessage = document.getElementById('qber-message');
        const keyTableContainer = document.getElementById('key-table-container');
        const keyTableBody = document.getElementById('key-table-body');
        const showTableBtn = document.getElementById('show-table-btn');
        const keyChartCtx = document.getElementById('key-chart').getContext('2d');
        let keyChart = null; // To hold the chart instance

        // --- Simulation State Variables ---
        let n = 0; // Number of qubits
        let aliceBits = [];
        let aliceBases = [];
        let bobBases = [];
        let bobResults = [];
        let eveBases = [];
        let eveMeasured = [];
        let qubitsForBob = null; // Holds the state Bob receives {bits, bases} (either directly from Alice or via Eve)
        let aliceKey = [];
        let bobKey = [];
        let qber = 0;
        let eveActive = false;
        let simulationStarted = false;
        let basesCompared = false;

        // --- BB84 Logic Functions ---

        /**
         * Generates a random bit (0 or 1).
         * @returns {number} 0 or 1.
         */
        function generateRandomBit() {
            return Math.floor(Math.random() * 2);
        }

        /**
         * Generates a random basis ('Z' for rectilinear, 'X' for diagonal).
         * @returns {string} 'Z' or 'X'.
         */
        function generateRandomBasis() {
            // Representing Z (rectilinear, |0>, |1>) and X (diagonal, |+>, |->)
            return Math.random() < 0.5 ? 'Z' : 'X';
        }

        /**
         * Formats a basis string for display with specific colors.
         * @param {string} basis - 'Z' or 'X'.
         * @returns {string} HTML formatted basis string.
         */
        function formatBasis(basis) {
            if (basis === 'Z') return '<span class="basis-z">Z</span>';
            if (basis === 'X') return '<span class="basis-x">X</span>';
            return '?'; // Handle undefined case
        }

        /**
         * Alice prepares her qubits (random bits and bases).
         * @param {number} num - Number of qubits.
         * @returns {object} Object containing Alice's bits and bases {bits, bases}.
         */
        function alicePreparation(num) {
            aliceBits = Array.from({ length: num }, generateRandomBit);
            aliceBases = Array.from({ length: num }, generateRandomBasis);
            // This object represents the quantum state Alice sends
            return {
                bits: [...aliceBits], // Send copies
                bases: [...aliceBases]
            };
        }

        /**
         * Simulates Eve intercepting, measuring, and resending qubits.
         * @param {number} num - Number of qubits.
         * @param {object} aliceData - The original qubits sent by Alice {bits, bases}.
         * @returns {object} Object containing the qubits Eve sends to Bob {bits, bases}, plus Eve's own bases and measurements.
         */
        function simulateEveMeasurement(num, aliceData) {
            eveBases = Array.from({ length: num }, generateRandomBasis);
            eveMeasured = [];
            let qubitsToSendToBob = { bits: [], bases: [] };

            for (let i = 0; i < num; i++) {
                const measurementBasis = eveBases[i];
                const preparedBasis = aliceData.bases[i];
                const preparedBit = aliceData.bits[i];
                let measuredBit;

                // Eve measures Alice's qubit
                if (preparedBasis === measurementBasis) {
                    measuredBit = preparedBit; // Correct measurement
                } else {
                    measuredBit = generateRandomBit(); // Random outcome due to basis mismatch
                }
                eveMeasured.push(measuredBit);

                // Eve prepares a *new* qubit based on her measurement *in the basis she used*
                // and sends it to Bob. This is crucial for introducing errors.
                qubitsToSendToBob.bits.push(measuredBit);
                qubitsToSendToBob.bases.push(measurementBasis); // Bob receives a qubit polarized according to Eve's basis
            }
            return {
                qubitsForBob: qubitsToSendToBob,
                eveBases: [...eveBases],
                eveMeasured: [...eveMeasured]
            };
        }


        /**
         * Bob measures the received qubits using his randomly chosen bases.
         * @param {number} num - Number of qubits.
         * @param {object} receivedQubits - The qubits Bob receives {bits, bases}.
         * @returns {object} Object containing Bob's chosen bases and measurement results {bases, results}.
         */
        function bobMeasurement(num, receivedQubits) {
             // Bob always chooses new bases when measuring
             const currentBobBases = Array.from({ length: num }, generateRandomBasis);
             const currentBobResults = [];

             if (!receivedQubits || !receivedQubits.bits || !receivedQubits.bases) {
                 console.error("Invalid receivedQubits data in bobMeasurement");
                 return { bases: [], results: [] };
             }

             for (let i = 0; i < num; i++) {
                 const measurementBasis = currentBobBases[i];
                 const incomingBasis = receivedQubits.bases[i]; // Basis of the qubit Bob received
                 const incomingBit = receivedQubits.bits[i]; // Bit value encoded in that basis
                 let measuredBit;

                 // Bob measures the qubit he received
                 if (incomingBasis === measurementBasis) {
                     measuredBit = incomingBit; // Correct measurement if bases match
                 } else {
                     measuredBit = generateRandomBit(); // Random outcome if bases mismatch
                 }
                 currentBobResults.push(measuredBit);
             }
            return {
                bases: currentBobBases,
                results: currentBobResults
            };
        }

        /**
         * Extracts the sifted key based on matching bases between Alice and Bob.
         * @param {Array<number>} sourceBits - The original bits (Alice's) or measured bits (Bob's).
         * @param {Array<string>} referenceBases - Alice's bases (used for comparison).
         * @param {Array<string>} measurementBases - Bob's bases (used for comparison).
         * @returns {Array<number>} The sifted key bits.
         */
        function extractSiftedKey(sourceBits, referenceBases, measurementBases) {
            let key = [];
            if (!sourceBits || sourceBits.length !== referenceBases.length || referenceBases.length !== measurementBases.length) {
                console.error("Array length mismatch in extractSiftedKey");
                return [];
            }
            for (let i = 0; i < referenceBases.length; i++) {
                if (referenceBases[i] === measurementBases[i]) {
                    key.push(sourceBits[i]);
                }
            }
            return key;
        }

        /**
         * Calculates the Quantum Bit Error Rate (QBER).
         * @param {Array<number>} keyA - Alice's sifted key.
         * @param {Array<number>} keyB - Bob's sifted key.
         * @returns {number} The QBER (fraction of mismatching bits). Returns -1 if keys are invalid or empty.
         */
        function calculateQBER(keyA, keyB) {
            if (!keyA || !keyB || keyA.length === 0 || keyA.length !== keyB.length) {
                return -1; // Indicate invalid input or no matching bases
            }
            let errors = 0;
            for (let i = 0; i < keyA.length; i++) {
                if (keyA[i] !== keyB[i]) {
                    errors++;
                }
            }
            return errors / keyA.length;
        }

        // --- UI Update Functions ---

        /** Clears all simulation data and resets the UI to initial state */
        function resetUI() {
            aliceBits = [];
            aliceBases = [];
            bobBases = [];
            bobResults = [];
            eveBases = [];
            eveMeasured = [];
            qubitsForBob = null;
            aliceKey = [];
            bobKey = [];
            qber = 0;
            eveActive = false;
            simulationStarted = false;
            basesCompared = false;

            aliceBitsSpan.textContent = '-';
            aliceBasesSpan.innerHTML = '-';
            bobBasesSpan.innerHTML = '-';
            bobResultsSpan.textContent = '-';
            evePanel.style.display = 'none';
            eveBasesSpan.innerHTML = '-';
            eveMeasuredSpan.textContent = '-';
            aliceKeySpan.textContent = '-';
            bobKeySpan.textContent = '-';
            qberSpan.textContent = 'N/A';
            qberMessage.textContent = '';
            keyTableBody.innerHTML = ''; // Clear table body
            keyTableContainer.style.display = 'none';
            showTableBtn.style.display = 'none';

            // Destroy existing chart if it exists
            if (keyChart) {
                keyChart.destroy();
                keyChart = null;
            }
             // Ensure canvas container height is reset or managed appropriately
            keyChartCtx.canvas.parentNode.style.height = '0px'; // Collapse chart area

            // Reset button states and text
            startBtn.disabled = false;
            startBtn.textContent = "Start Simulation";
            eveBtn.disabled = true;
            compareBtn.disabled = true;
        }

        /** Updates the display panels (Alice, Bob, Eve) with current simulation data */
        function updatePanels() {
            aliceBitsSpan.textContent = aliceBits.join('');
            aliceBasesSpan.innerHTML = aliceBases.map(formatBasis).join('');
            bobBasesSpan.innerHTML = bobBases.map(formatBasis).join('');
            bobResultsSpan.textContent = bobResults.join('');

            if (eveActive) {
                evePanel.style.display = 'block';
                eveBasesSpan.innerHTML = eveBases.map(formatBasis).join('');
                eveMeasuredSpan.textContent = eveMeasured.join('');
            } else {
                evePanel.style.display = 'none';
            }

            // Only show keys after comparison
            aliceKeySpan.textContent = basesCompared ? aliceKey.join('') : '-';
            bobKeySpan.textContent = basesCompared ? bobKey.join('') : '-';
        }

        /** Generates the rows for the detailed table comparing steps */
        function generateDetailedTable() {
            let tableHTML = '';
            for (let i = 0; i < n; i++) {
                const aliceBasis = aliceBases[i] ?? '?';
                const bobBasis = bobBases[i] ?? '?';
                const match = aliceBasis === bobBasis;
                const aliceSiftedBit = match ? (aliceBits[i] ?? '?') : '-';
                const bobSiftedBit = match ? (bobResults[i] ?? '?') : '-';
                const rowClass = match ? '' : 'mismatch'; // Highlight mismatch rows slightly

                tableHTML += `
                    <tr class="${i % 2 === 0 ? 'bg-white' : 'bg-gray-50'} ${rowClass}">
                        <td class="px-3 py-1 whitespace-nowrap text-sm text-gray-500">${i}</td>
                        <td class="px-3 py-1 whitespace-nowrap text-sm font-mono">${aliceBits[i] ?? '?'}</td>
                        <td class="px-3 py-1 whitespace-nowrap text-sm font-mono">${formatBasis(aliceBasis)}</td>
                        <td class="px-3 py-1 whitespace-nowrap text-sm font-mono">${eveActive ? formatBasis(eveBases[i] ?? '?') : '-'}</td>
                        <td class="px-3 py-1 whitespace-nowrap text-sm font-mono">${eveActive ? (eveMeasured[i] ?? '?') : '-'}</td>
                        <td class="px-3 py-1 whitespace-nowrap text-sm font-mono">${formatBasis(bobBasis)}</td>
                        <td class="px-3 py-1 whitespace-nowrap text-sm font-mono">${bobResults[i] ?? '?'}</td>
                        <td class="px-3 py-1 whitespace-nowrap text-sm ${match ? 'match font-semibold text-green-700' : 'mismatch text-red-700'}">${match ? 'Yes' : 'No'}</td>
                        <td class="px-3 py-1 whitespace-nowrap text-sm font-mono key-bit ${match && aliceSiftedBit !== bobSiftedBit ? 'text-red-600' : ''}">${aliceSiftedBit}</td>
                        <td class="px-3 py-1 whitespace-nowrap text-sm font-mono key-bit ${match && aliceSiftedBit !== bobSiftedBit ? 'text-red-600' : ''}">${bobSiftedBit}</td>
                    </tr>`;
            }
            keyTableBody.innerHTML = tableHTML;
            showTableBtn.style.display = 'inline-block'; // Show the toggle button
            // Ensure table is visible if button says "Hide"
            if (showTableBtn.textContent.includes("Hide")) {
                 keyTableContainer.style.display = 'block';
            }
        }

        /** Updates the QBER display and provides a contextual message */
        function updateQBERDisplay() {
            qberMessage.textContent = ''; // Clear previous message
            qberMessage.className = 'text-sm text-gray-600 mt-1'; // Reset classes
            qberSpan.className = 'font-bold text-xl text-purple-700'; // Reset classes

            if (qber === -1) {
                qberSpan.textContent = 'Error';
                qberSpan.classList.add('text-red-600');
                qberMessage.textContent = '(No matching bases found or key length mismatch)';
                qberMessage.classList.add('text-red-600');
            } else {
                qberSpan.textContent = `${(qber * 100).toFixed(2)}%`;
                const qberThreshold = 0.15; // Example threshold

                if (qber > qberThreshold) {
                     qberMessage.textContent = 'High QBER suggests potential eavesdropping! Key should be discarded.';
                     qberMessage.classList.add('text-red-600','font-semibold');
                     qberSpan.classList.add('text-red-600');
                } else if (eveActive && qber > 0) {
                     qberMessage.textContent = 'Non-zero QBER detected. Eve\'s interception likely introduced errors.';
                     qberMessage.classList.add('text-orange-600','font-semibold');
                     qberSpan.classList.add('text-orange-600');
                } else if (qber === 0) {
                     qberMessage.textContent = `Keys match perfectly. ${eveActive ? "Eve was unsuccessful or very lucky!" : "Secure channel likely."}`;
                     qberMessage.classList.add('text-green-600','font-semibold');
                     qberSpan.classList.add('text-green-600');
                } else { // QBER is low but > 0, and Eve wasn't simulated
                     qberMessage.textContent = 'Low QBER. Keys mostly consistent (minor noise/simulation effect).';
                     // Keep default purple color for QBER span in this case
                }
            }
        }

        /** Updates or creates the key comparison chart using Chart.js */
        function updateChart() {
            const labels = Array.from({ length: aliceKey.length }, (_, i) => `${i}`); // Use 0-based index for labels

            // Destroy previous chart instance if it exists
            if (keyChart) {
                keyChart.destroy();
                keyChart = null;
            }

            // Don't draw chart if keys are empty
            if (aliceKey.length === 0) {
                 keyChartCtx.canvas.parentNode.style.height = '0px'; // Collapse chart area if no data
                 return;
            }

             // Set container height before creating chart
             keyChartCtx.canvas.parentNode.style.height = '250px'; // Example fixed height

            keyChart = new Chart(keyChartCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Alice\'s Sifted Bit',
                            data: aliceKey,
                            borderColor: 'rgba(59, 130, 246, 0.8)', // Blue
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderWidth: 2,
                            stepped: true, // Show as steps
                            pointRadius: 3,
                            pointBackgroundColor: 'rgba(59, 130, 246, 1)',
                        },
                        {
                            label: 'Bob\'s Sifted Bit',
                            data: bobKey,
                            borderColor: 'rgba(16, 185, 129, 0.8)', // Green (Changed from red for Bob)
                            backgroundColor: 'rgba(16, 185, 129, 0.2)',
                            borderWidth: 2,
                            stepped: true, // Show as steps
                            pointRadius: 3,
                            pointBackgroundColor: 'rgba(16, 185, 129, 1)',
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // Allow chart to fill container height
                    scales: {
                        y: {
                            beginAtZero: true,
                            min: -0.1, // Give space below 0
                            max: 1.1, // Give space above 1
                            ticks: {
                                stepSize: 1, // Only show ticks at 0 and 1
                                callback: function(value) {
                                    if (value === 0 || value === 1) return value;
                                }
                            },
                            title: { display: true, text: 'Bit Value' }
                        },
                        x: {
                             title: { display: true, text: 'Sifted Key Bit Index' }
                        }
                    },
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: true, text: 'Alice vs Bob Sifted Key Comparison', font: { size: 16 } },
                        tooltip: {
                            mode: 'index', // Show tooltips for both datasets at the same index
                            intersect: false,
                            callbacks: {
                                 label: function(context) {
                                     let label = context.dataset.label || '';
                                     if (label) { label += ': '; }
                                     label += context.parsed.y;
                                     // Add mismatch indicator
                                     const index = context.dataIndex;
                                     if (aliceKey[index] !== bobKey[index]) {
                                         label += ' (Mismatch!)';
                                     }
                                     return label;
                                 }
                            }
                        }
                    },
                    interaction: { // Improve hover interaction
                        mode: 'index',
                        intersect: false
                    },
                     // Highlight mismatches directly on the chart (Advanced - requires custom plugin or annotation)
                     // For simplicity, relying on tooltip and QBER message for now.
                }
            });
        }


        // --- Event Listeners ---

        /** Handles the Start Simulation / Start New Simulation button click */
        startBtn.addEventListener('click', () => {
            resetUI(); // Clear previous run completely
            n = parseInt(numQubitsInput.value);
            if (isNaN(n) || n < 4 || n > 100) { // Added validation
                 alert("Please enter a valid number of qubits (4-100).");
                 resetUI(); // Ensure UI is reset if input is invalid
                 return;
            }
            simulationStarted = true;
            eveActive = false; // Start without Eve by default
            basesCompared = false;

            // 1. Alice prepares qubits
            const aliceData = alicePreparation(n);
            qubitsForBob = aliceData; // Initially, Bob receives directly from Alice

            // 2. Bob measures
            const bobData = bobMeasurement(n, qubitsForBob);
            bobBases = bobData.bases;
            bobResults = bobData.results;

            // Update UI and button states
            updatePanels();
            startBtn.disabled = true; // Disable start until compare/reset
            eveBtn.disabled = false; // Allow Eve simulation before comparison
            compareBtn.disabled = false; // Allow comparison
        });

        /** Handles the Simulate Eve button click */
        eveBtn.addEventListener('click', () => {
            if (!simulationStarted) {
                alert("Please start the simulation first.");
                return;
            }
             if (basesCompared) {
                 alert("Cannot simulate Eve after bases have been compared. Please start a new simulation.");
                 return;
             }

            eveActive = true;

            // 1. Get Alice's original data (already generated in startBtn)
            const aliceData = { bits: aliceBits, bases: aliceBases };

            // 2. Eve intercepts and measures
            const eveResult = simulateEveMeasurement(n, aliceData);
            eveBases = eveResult.eveBases;
            eveMeasured = eveResult.eveMeasured;
            qubitsForBob = eveResult.qubitsForBob; // Bob now receives from Eve

            // 3. Bob measures the qubits *sent by Eve*
            // Bob needs to choose new bases for this measurement round
            const bobData = bobMeasurement(n, qubitsForBob);
            bobBases = bobData.bases; // Update Bob's bases
            bobResults = bobData.results; // Update Bob's results

            // Update UI and button states
            updatePanels();
            eveBtn.disabled = true; // Eve can only intercept once per simulation run
            compareBtn.disabled = false; // Comparison is still possible
        });

        /** Handles the Compare Bases & Get Key button click */
        compareBtn.addEventListener('click', () => {
            if (!simulationStarted) {
                alert("Please start the simulation first.");
                return;
            }
              if (basesCompared) {
                 alert("Bases already compared for this run.");
                 return;
             }

            basesCompared = true;

            // 3. Extract Sifted Keys based on *Alice's* original bases and *Bob's* final bases
            aliceKey = extractSiftedKey(aliceBits, aliceBases, bobBases);
            bobKey = extractSiftedKey(bobResults, aliceBases, bobBases);

            // 4. Calculate QBER
            qber = calculateQBER(aliceKey, bobKey);

            // Update UI
            updatePanels(); // Show keys
            updateQBERDisplay(); // Show QBER and message
            generateDetailedTable(); // Generate the table now that comparison is done
            updateChart(); // Generate/Update the chart

            // Disable further actions for this run, enable restart
            eveBtn.disabled = true;
            compareBtn.disabled = true;
            startBtn.disabled = false; // Allow starting a new simulation
            startBtn.textContent = "Start New Simulation"; // Change button text
        });

        /** Handles the Show/Hide Detailed Table button click */
        showTableBtn.addEventListener('click', () => {
            const isHidden = keyTableContainer.style.display === 'none';
            keyTableContainer.style.display = isHidden ? 'block' : 'none';
            showTableBtn.textContent = isHidden ? 'Hide Detailed Steps' : 'Show Detailed Steps';
        });

        // --- Initial State ---
        document.addEventListener('DOMContentLoaded', resetUI); // Initialize the UI on page load

    </script>
</body>
</html>
